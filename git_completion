##############################
# Alias basiques
##############################

alias gs='git status'
alias g.='git add . -A'
alias g.c='git add . -A && git commit -m'
alias gc='git commit -m'

alias gm='git merge'
alias gmf='git merge --no-ff'

alias gba='git branch -a'
alias gbgone='git fetch -p && git-clean-gone'

alias gcout='git checkout'
alias gsw='git switch'
alias gswc='git switch -c'

alias gdu='git diff @{upstream}'
alias gfd='git fetch --dry-run'

alias glog='git log --stat --pretty=format:"%h %s %d" --graph'
alias glr='git remote -v'
alias glt='git tag'

##############################
# Fonctions
##############################

function git-clean-gone() {
    branches=$(git branch -vv | grep ': gone]' | awk '{print $1}')
    
    if [ -z "$branches" ]; then
        echo "Aucune branche locale morte trouvÃ©e. ğŸ˜"
        return
    fi

    echo "âš ï¸ Branches locales sans remote dÃ©tectÃ©es :"
    echo "$branches"
    echo
    read -p "Es-tu sÃ»r de vouloir supprimer toutes ces branches ? (yes/no) : " confirm

    if [ "$confirm" = "yes" ]; then
        echo "$branches" | xargs git branch -D
        echo "Branches supprimÃ©es ğŸ’€"
    else
        echo "Rien n'a Ã©tÃ© supprimÃ© ğŸ‘"
    fi
}

# Fonction de complÃ©tion personnalisÃ©e pour g.c
_gc_completion() {
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"
    
    # Reconstruit la ligne complÃ¨te (sans g.c)
    local full_line="${COMP_WORDS[@]:1}"
    full_line="${full_line% *}"  # EnlÃ¨ve le dernier mot incomplet
    
    # Liste de suggestions de messages de commit avec emojis (tri alphabÃ©tique sur le texte)
    local suggestions=(
        "ğŸ“ˆ benchmark: "
        "âš™ï¸ build-system: "
        "ğŸ“¦ build: "
        "ğŸ”¨ chore: "
        "ğŸ’š ci: "
        "ğŸ§¹ cleanup: "
        "ğŸ”§ config: "
        "ğŸ§± data: "
        "ğŸš€ deploy: "
        "ğŸ§° deps: "
        "ğŸ§‘â€ğŸ’» dev: "
        "ğŸ“ docs: "
        "âœ¨ feature: "
        "ğŸ› fix: "
        "ğŸ”¥ hotfix: "
        "ğŸŒ i18n: "
        "ğŸ¨ improve: "
        "ğŸ‰ init: "
        "ğŸ§  logic: "
        "ğŸ§¾ meta: "
        "âš¡ perf: "
        "â™»ï¸ refactor: "
        "ğŸ—‘ï¸ remove: "
        "âª revert: "
        "ğŸ”’ security: "
        "ğŸ’„ style: "
        "ğŸ“ structure: "
        "âœï¸ typo: "
        "âœ… test: "
        "ğŸª„ ux: "
        "â¬†ï¸ update: "
        "ğŸ§ª experiment: "
        "ğŸš§ wip: "
    )
    
    # Si on est au premier mot (juste aprÃ¨s g.c)
    if [[ $COMP_CWORD -eq 1 ]]; then
        local matches=()
        for suggestion in "${suggestions[@]}"; do
            local text_only="${suggestion#* }"
            if [[ "$text_only" == "$cur"* ]]; then
                matches+=("$suggestion")
            fi
        done
        COMPREPLY=("\"${matches[@]}")
    # Si on a dÃ©jÃ  commencÃ© Ã  taper (plusieurs mots)
    else
        # Reconstruit tout ce qui a Ã©tÃ© tapÃ© jusqu'ici
        local typed=""
        for ((i=1; i<COMP_CWORD; i++)); do
            typed+="${COMP_WORDS[i]} "
        done
        typed+="$cur"
        
        local matches=()
        for suggestion in "${suggestions[@]}"; do
            if [[ "$suggestion" == "$typed"* ]]; then
                # Retourne seulement la partie manquante
                matches+=("${suggestion}")
            fi
        done
        
        # Si aucune correspondance exacte, dÃ©sactive la complÃ©tion
        if [[ ${#matches[@]} -eq 0 ]]; then
            COMPREPLY=()
        else
            COMPREPLY=("${matches[@]}")
        fi
    fi
}

# Associe la fonction de complÃ©tion Ã  votre alias
complete -o nospace -F _gc_completion g.c
complete -o nospace -F _gc_completion gc

info() { echo "â„¹ï¸  $1"; }

# Ã€ la fin du fichier, aprÃ¨s les `complete` :
if [[ ${BASH_SOURCE[0]} == "$HOME/.bashrc" ]]; then
    info "AutocomplÃ©tion Git chargÃ©e correctement âœ…"
fi