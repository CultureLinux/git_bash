##############################
# Alias basiques
##############################

alias gs='git status'
alias g.='git add . -A'
alias g.c='git add . -A && git commit -m'
alias gc='git commit -m'

alias gm='git merge'
alias gmf='git merge --no-ff'

alias gba='git branch -a'

alias gcout='git checkout'
alias gsw='git switch'
alias gswc='git switch -c'

alias gdu='git diff @{upstream}'
alias gfd='git fetch --dry-run'

alias glog='git log --stat --pretty=format:"%h %s %d" --graph'
alias glr='git remote -v'
alias glt='git tag'

##############################
# Fonctions
##############################

# function git-clean-gone() {
    local branches
    branches=$(git branch -vv | grep ': gone]' | awk '{print $1}')
    
    if [ -z "$branches" ]; then
        echo "Aucune branche locale morte trouvée. 😎"
        return
    fi

    echo "⚠️ Branches locales sans remote détectées :"
    echo "$branches"
    echo
    read -p "Es-tu sûr de vouloir supprimer toutes ces branches ? (yes/no) : " confirm

    if [ "$confirm" = "yes" ]; then
        echo "$branches" | xargs git branch -D
        echo "Branches supprimées 💀"
    else
        echo "Rien n'a été supprimé 👍"
    fi
}

# Alias pratique
alias gcgone='git-clean-gone'

# Fonction de complétion personnalisée pour g.c
_gc_completion() {
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"
    
    # Reconstruit la ligne complète (sans g.c)
    local full_line="${COMP_WORDS[@]:1}"
    full_line="${full_line% *}"  # Enlève le dernier mot incomplet
    
    # Liste de suggestions de messages de commit avec emojis (tri alphabétique sur le texte)
    local suggestions=(
        "📦 build: "
        "🔧 config: "
        "💚 ci: "
        "🧱 data: "
        "📝 docs: "
        "✨ feature: "
        "🐛 fix: "
        "🎨 improve: "
        "🎉 init: "
        "⚡ perf: "
        "🔥 remove: "
        "♻️ refactor: "
        "⏪ revert: "
        "🔒 security: "
        "💄 style: "
        "✏️ typo: "
        "✅ test: "
        "🚀 deploy: "
        "⬆️ update: "
        "🚧 wip: "
        "🔨 chore: "
        "🛠 hotfix: "
        "🌐 i18n: "
        "📈 benchmark: "
    )
    
    # Si on est au premier mot (juste après g.c)
    if [[ $COMP_CWORD -eq 1 ]]; then
        local matches=()
        for suggestion in "${suggestions[@]}"; do
            local text_only="${suggestion#* }"
            if [[ "$text_only" == "$cur"* ]]; then
                matches+=("$suggestion")
            fi
        done
        COMPREPLY=("\"${matches[@]}")
    # Si on a déjà commencé à taper (plusieurs mots)
    else
        # Reconstruit tout ce qui a été tapé jusqu'ici
        local typed=""
        for ((i=1; i<COMP_CWORD; i++)); do
            typed+="${COMP_WORDS[i]} "
        done
        typed+="$cur"
        
        local matches=()
        for suggestion in "${suggestions[@]}"; do
            if [[ "$suggestion" == "$typed"* ]]; then
                # Retourne seulement la partie manquante
                matches+=("${suggestion}")
            fi
        done
        
        # Si aucune correspondance exacte, désactive la complétion
        if [[ ${#matches[@]} -eq 0 ]]; then
            COMPREPLY=()
        else
            COMPREPLY=("${matches[@]}")
        fi
    fi
}

# Associe la fonction de complétion à votre alias
complete -o nospace -F _gc_completion g.c
complete -o nospace -F _gc_completion gc